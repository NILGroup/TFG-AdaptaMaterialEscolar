%---------------------------------------------------------------------%
%																	  %
%               Capítulo 5 - AdaptaMaterialEscolar				  	  %
%																	  %
%---------------------------------------------------------------------%

%------Primera sección: Captura de requisitos------%
\section{Front-End}
%--------------------------------------------------%
\label{cap5:sec:implementacion:FrontEnd}

	Para la parte Font-End se ha optado por un diseño simple, limpio y lo más ordenado posible, usando HTML y CSS para la creación de los componentes y Javascript para la funcionalidad de éstos. Así mismo, nos hemos apoyado en estos principios de diseño:
	\begin{itemize}
		\item Principio de proximidad. Este principio establece que si hay dos o más elementos que están próximos, entonces están relacionados. Al estar agrupados, el usuario sabe que están relacionados y, por lo tanto, facilita su aprendizaje. En nuestro caso, en la figura \ref{fig:Prinprox1} se puede ver que los elementos de la barra de herramientas del editor, al estar sus elementos agrupados y próximos, están relacionados (el formato de texto, la alineación del mismo...). Además, el usuario sabe que los elementos que se encuentran en la parte superior del editor también lo están, ya que son los diferentes tipos de adaptaciones y ejercicios que soporta la aplicación.
		\begin{figure}[ht!]
			\begin{center}
				\includegraphics[width=0.94\textwidth]{Imagenes/Bitmap/Prinprox1}
				\caption{Ejemplo de principio de proximidad en nuestra interfaz}
				\label{fig:Prinprox1}
			\end{center}
		\end{figure}
	
		\item Principio de consistencia externa. Este principio establece que las aplicaciones desarrolladas deben ser consistentes con las expresiones habituales dentro de un sistema específico, es decir, mantener los clics, los menús contextuales, los mismos atajos de teclado... En nuestro caso, este principio se cumple ya que se pueden seguir usando los atajos de teclado, como copiar (ctrl+c), pegar (ctrl+v), cortar (ctrl+x), seleccionar todo (ctrl+a), etc., dentro de los distintos componentes de la aplicación.
		
		\item Principio de visibilidad y feedback. Este principio establece, por un lado, cómo la interfaz emplea distintos mecanismos para saber su estado actual, y también qué acciones se pueden hacer en un determinado momento; y por el otro, la información que le proporcionamos al usuario de lo que está sucediendo. En nuestro caso, en la figura \ref{fig:PrinVisFeedback} se puede ver qué opciones hay disponibles al subir un fichero: puede empezar a escribir en el editor, usar los diferentes ejercicios y adaptaciones... 
		
		\begin{figure}[ht!]
			\begin{center}
				\includegraphics[width=1\textwidth]{Imagenes/Bitmap/PrinVisFeedback}
				\caption{Ejemplo de principio de visibilidad y feedback en nuestra interfaz}
				\label{fig:PrinVisFeedback}
			\end{center}
		\end{figure}
	
		Así mismo, en ciertos componentes mostramos al usuario información adicional para que sepa lo que está sucediendo, como ocurre en la sopa de letras (figura \ref{fig:prinVisFeedbackWordsearch}), donde al poner un número inferior a uno en las filas o en las columnas se le muestra un mensaje de información en el que dicho valor debe ser superior a cero, e incluso qué campos debe rellenar como mínimo para poder crear la sopa de letras o el significado de ciertas opciones en dicho componente (figura \ref{fig:prinVisFeedbackInfo}).
	
		\begin{figure}[ht!]
			\begin{center}
				\includegraphics[width=0.84\textwidth]{Imagenes/Bitmap/prinVisFeedbackWordsearch}
				\caption{Ejemplo de feedback en la sopa de letras (I)}
				\label{fig:prinVisFeedbackWordsearch}
			\end{center}
		\end{figure}
	
		\begin{figure}[ht!]
			\begin{center}
				\includegraphics[width=0.84\textwidth]{Imagenes/Bitmap/prinVisFeedbackInfo}
				\caption{Ejemplo de feedback en la sopa de letras (II)}
				\label{fig:prinVisFeedbackInfo}
			\end{center}
		\end{figure}
	\end{itemize}

\section{Componentes}
\label{cap5:sec:implementacion:componentes}

	\subsection{Sopa de letras}
		La sopa de letras es un paquete NPM (\textit{Node Package Manager}) disponible en \url{https://www.npmjs.com/package/@blex41/word-search}. Dado un objeto de opciones devuelve, o bien un array de caracteres donde cada posición es un carácter de la sopa de letras generada; o bien un array de strings donde cada posición es una fila de dicha sopa. Las opciones que tiene disponible este paquete son las siguientes:
		\begin{itemize}
			\item cols: Es un número entero que representa las columnas que tendrá la sopa de letras. Por defecto tiene un valor de diez.
			\item rows: Es un número entero que representa las filas que tendrá la sopa de letras. Por defecto tiene un valor de diez.
			\item disabledDirections: Es un array de strings que representa las direcciones cardinales (``N'', ``S'', ``E'', ``W'', ``NE'', ``NW'', ``SE'', ``SW'') donde no se quiere colocar una palabra en la sopa de letras. Por defecto tiene un valor vacío, es decir, todas las direcciones están permitidas.
			\item dictionary: Es un array de strings que representa las palabras a buscar en la sopa de letras. Por defecto tiene un valor vacío.
			\item maxWords: Es un número entero que representa el número de palabras máximo que se insertarán en la sopa de letras. Por defecto tiene un valor de veinte. En el caso de que se sobrepase este número, no se insertarán más palabras.
			\item backwardsProbability: Es un número decimal que representa la probabilidad que tiene cada palabra de escribirse al revés. Solo funciona si no se deshabilita, en una dirección cardinal, uno de los extremos (por ejemplo, si se quiere escribir una palabra al revés en la dirección vertical, se debe tener las direcciones cardinales ``N'' y ``S'' habilitadas, no solo una de ellas. Lo mismo pasa con las direcciones horizontal y diagonal). Por defecto tiene un valor de 0.3, y puede oscilar entre cero y uno.
			\item upperCase: Es un booleano que indica si las letras se quieren en mayúscula (\textit{true}) o no (\textit{false}) en la sopa de letras. Por defecto tiene el valor \textit{true}.
			\item diacritics: Es un booleano que indica si las letras deberían mantener las tildes en la sopa de letras. Por defecto tiene el valor \textit{false}, es decir, no mantener las tildes en la sopa de letras.
		\end{itemize}
		En el caso de que alguna de estas opciones no se modificasen, no daría ningún error, sino que cogería el valor por defecto que tuvieran.
		Así mismo, este paquete dispone de una serie de funciones accesibles cuando se crea la estancia de la sopa de letras:
		\begin{itemize}
			\item grid(): Devuelve un array de caracteres donde cada posición representa una letra de la sopa de letras.
			\item toString(): Devuelve un array de strings donde cada posición representa una fila de la sopa de letras.
			\item words(): Devuelve un array de objetos con las palabras que se han insertado correctamente en la sopa de letras. Cada objeto tiene tres campos:
			\begin{itemize}
				\item word: la palabra que está en el campo \textit{dictionary}.
				\item clean: este campo depende de las opciones de \textit{upperCase} y \textit{diacritics}, es decir, se escribirá la palabra del campo \textit{word} con o sin mayúsculas y con o sin tildes (dependiendo si los valores de dichas opciones están a \textit{true} o \textit{false}).
				\item path: contiene un array de objetos con las posiciones de cada letra de la palabra en la sopa de letras.
			\end{itemize}
			\item dump(): Devuelve un objeto que representa el estado de la sopa de letras (es una \textit{snapshot} del tablero).
			\item load(backup): Carga el parámetro \textit{backup} que representa un estado de la sopa de letras generado previamente con \textit{dump()}.
			\item read(start, end): Devuelve un string con las letras que se forman al leer las posiciones de \textit{start} a \textit{end}.
		\end{itemize}
		
		En la figura \ref{fig:wordsearch} se puede ver la interfaz de la generación de la sopa de letras que hemos implementado. Para poder crearla, se tienen que rellenar, como mínimo, lo siguientes campos:
		\begin{itemize}
			\item Filas: El número de filas que tendrá la sopa de letras. 
			\item Columnas: El número de columnas que tendrá la sopa de letras.
			\item Palabras: Las palabras que se insertarán en la sopa de letras, separadas mediante comas.
			\item Dirección: Las direcciones en las que se quiere insertar la palabra. Como mínimo se debe activar una dirección para poder generar la sopa de letras.
		\end{itemize}
		
		\begin{figure}[ht!]
			\begin{center}
				\includegraphics[width=0.94\textwidth]{Imagenes/Bitmap/wordsearch}
				\caption{Interfaz de generación de la sopa de letras}
				\label{fig:wordsearch}
			\end{center}
		\end{figure}
		
		También se han añadido otras opciones que están disponibles en el paquete, explicadas al principio de esta sección, y que no son obligatorias:
		\begin{itemize}
			\item Activar escritura al revés: Activa la probabilidad de escribir cada palabra al revés. En el caso de que esta opción no se active, la probabilidad será cero. Si se activa, aparecerá una barra deslizante para establecer dicha probabilidad.
			\item Mantener tildes: Si se activa, las tildes que tengan las palabras se mantendrán cuando se genere la sopa de letras. Hay que tener en cuenta que este paquete usa el alfabeto inglés, por lo que si se quiere poner alguna palabra que contenga la ``Ñ'', se deberá activar esta opción.
		\end{itemize}
		Así como un botón para resetear los campos de la sopa de letras y una opción para escribir en el editor las palabras que debe buscar el usuario.
		
		Una vez que se han rellenado las opciones mínimas se activará el botón ``Vista previa''. La funcionalidad de este botón se puede ver en la figura \ref{fig:wordsearchSequence} . Al darle clic a dicho botón, se llama a la función ``handleClick'', en cuyo cuerpo se hace una llamada al despachador pasándole como acción \textit{createWordSearch}. En el fichero \textit{wordsearch.actions.js} se buscará la acción que corresponde con el parámetro pasado, en este caso es \textit{createWordSearch}, donde buscará el tipo correspondiente en el fichero \textit{worsearch.types.js} y lo devolverá. Una vez buscado este tipo de acción, que en este caso es \textit{WordSearchActionTypes.CREATE\_WORDSEARCH}, el despachador llamará al reductor (que se encuentra en \textit{wordsearch.reducer.js}) y buscará la opción \textit{CREATE\_WORDSEARCH}. Una vez encontrado, devolverá el estado actual junto con la creación de la sopa de letras en el campo \textit{wordSearchObject}, el cual se crea gracias a una llamada a la función \textit{createWordSearch(wordSearch, options)} que se encuentra en el fichero \textit{wordsearch.utils.js}, pasándole como parámetro el campo \textit{wordSearchObject}, y el objeto opciones mencionado al principio de esta sección (\textit{cols, rows, dictionary, maxWords, disabledDirections, backwardsProbability, diacritics}). Esta función primero transforma a entero las opciones \textit{rows, cols} y \textit{maxWords}, y creará el array de palabras (\textit{dictionary}) llamando a la función \textit{split(``,'')} de la librería String, y para cada palabra, quitará sus espacios llamando a \textit{trim()}. Una vez hecho esto, se comprobará si las filas y las columnas son mayores que cero. En caso afirmativo, se procederá a crear el objeto \textit{wordsearch} pasándole como parámetro esas opciones y devolviéndolo. En caso de que haya algún error, se devolverá null. Tras devolver el estado modificado, el componente \textit{WordSearchModal} llama a la función \textit{generateTable()}. Esta función devuelve el componente de la sopa de letras \textit{WordSearch}, pasándole como datos la función \textit{grid()} descrita anteriormente, en el caso de que el objeto \textit{wordSearchObject} sea distinto de null (este objeto lo lee a través del selector \textit{selectWordSearchModalWordSearchObj}, el cual devuelve el campo \textit{wordSearchObject} del estado actual que se encuentra en el reductor), o directamente devuelve null en el caso de que \textit{wordSearchObject} también lo sea. Así mismo, esta función actualiza los mensajes de error a través de \textit{updateError(error)}, que llamará al despachador y hará el mismo proceso que con \textit{createWordSearch()}.
		
		\begin{figure}[ht!]
			\begin{center}
				\includegraphics[width=1\textwidth]{Imagenes/Bitmap/wordsearchSequence}
				\caption{Diagrama de secuencia de la generación de la sopa de letras}
				\label{fig:wordsearchSequence}
			\end{center}
		\end{figure}
	
		Al finalizar , y si no ha habido errores, se mostrará una vista previa de la sopa de letras en dicho modal y se activará el botón "Aceptar", el cual si se le da clic se escribirá en el editor la sopa de letras.
		